#!/bin/env python2

import gevent.monkey
gevent.monkey.patch_all()

import logging
import os
import re
import traceback
from multiprocessing import cpu_count

from gevent.pool import Pool

import argh
from easycmd import cmd
from misc import AtomicReplace

AUDIO_EXTS = ['flac', 'aac', 'm4a', 'wav', 'ogg', 'mp3', 'wma', 'opus', 'webm', 'mp4']
DRY = False


def do(i, n, fn, src, dest, *args):
	print "Doing {}/{}: {} {}".format(i, n, fn.__name__, dest)
	try:
		dest_dir = os.path.dirname(dest)
		if not os.path.exists(dest_dir):
			os.makedirs(dest_dir)
		fn(src, dest, *args)
		print "Done {}/{}".format(i, n)
		return True
	except Exception:
		print "Failed {}/{}".format(i, n)
		traceback.print_exc()
		return False

def copy(src, dest):
	if not DRY:
		with AtomicReplace(dest) as tmp:
			cmd(['cp', src, tmp])


def convert(src, dest, ffargs):
	if not DRY:
		with AtomicReplace(dest) as tmp:
			cmd(['ffmpeg', '-i', src] + ffargs + [tmp])


def make_safe(s):
	return re.sub(r'[^a-zA-Z0-9/ .-]', '_', s)


def get_dest(src_root, dest_root, src, safe=False, ext='mp3'):
	rel_src_dir = os.path.relpath(os.path.dirname(src), src_root)
	src_name = os.path.basename(src)
	src_name, src_ext = os.path.splitext(src_name)
	dest_name = "{}.{}".format(src_name, ext or src_ext[1:])
	if safe:
		rel_src_dir = make_safe(rel_src_dir)
		dest_name = make_safe(dest_name)
	return os.path.join(dest_root, rel_src_dir, dest_name)


def do_file(pool, i, n, src, dest, ffargs, force=False):
	if os.path.exists(dest) and not force:
		print "Skipping {}/{}: already exists {}".format(i, n, dest)
		return
	_, ext = os.path.splitext(dest)
	ext = ext[1:]
	if src.lower().endswith(ext) or not is_audio(src):
		return pool.spawn(do, i, n, copy, src, dest)
	else:
		return pool.spawn(do, i, n, convert, src, dest, ffargs)


def get_items(src_root, dest_root, stdin=False, safe=False, ext='mp3', non_audio=False):
	if stdin:
		items = (os.path.split(filepath.rstrip('\n')) for filepath in sys.stdin)
	else:
		items = (
			(path, filename)
			for path, _, files in os.walk(src_root)
			for filename in files
		)
	for path, filename in items:
		if non_audio or is_audio(filename):
			src = os.path.join(path, filename)
			if not os.path.exists(src):
				logging.warning("Path {!r} does not exist, skipping".format(src))
				continue
			dest = get_dest(src_root, dest_root, src, safe=safe, ext=ext if is_audio(filename) else None)
			yield src, dest


def is_audio(path):
	return any(path.lower().endswith(".{}".format(audio_ext)) for audio_ext in AUDIO_EXTS)


def get_exists_in_dest(dest_root):
	for path, _, files in os.walk(dest_root):
		for filename in files:
			if any(filename.lower().endswith(".{}".format(ext)) for ext in AUDIO_EXTS):
				filepath = os.path.join(path, filename)
				yield filepath


@argh.arg('--stdin', default=False)
@argh.arg('--force', default=False)
@argh.arg('--safe', default=False)
@argh.arg('--ext', default='mp3')
@argh.arg('--concurrency', default=cpu_count())
@argh.arg('--delete', default=False)
@argh.arg('--non-audio', default=False)
def main(src_root, dest_root, *ffargs, **kwargs):
	force, stdin, safe, ext, concurrency, delete, non_audio = (kwargs[k] for k in ('force', 'stdin', 'safe', 'ext', 'concurrency', 'delete', 'non_audio'))
	items = list(get_items(src_root, dest_root, stdin=stdin, safe=safe, ext=ext, non_audio=non_audio))
	if delete:
		exists = set(get_exists_in_dest(dest_root))
		to_delete = exists - set(dest for src, dest in items)
		print "Deleting {} existing items".format(len(to_delete))
		for path in to_delete:
			os.remove(path)
	n = len(items)
	jobs = []
	pool = Pool(concurrency)
	try:
		for i, (src, dest) in enumerate(items):
			jobs.append(do_file(pool, i, n, src, dest, list(ffargs), force))
	finally:
		pool.join()
	if not all(job.get() for job in jobs if job):
		raise Exception("One or more jobs failed")


if __name__ == '__main__':
	import sys
	argh.dispatch_command(main)
