
# Fix path, which on some systems ends up with /usr/bin overriding /usr/local/bin
PATH=$(/usr/bin/python2 -c '
import sys
path = sys.argv[1].split(":")
dedup_path = []
for p in path:
	if p not in dedup_path:
		dedup_path.append(p)
if "/usr/bin" in dedup_path:
	dedup_path.remove("/usr/bin")
	dedup_path.append("/usr/bin")
print ":".join(dedup_path)
' "$PATH")

# PS1 config
PS1='[\t] \u@\h:\w\$ '
source "$HOME/bin/alerts.ps1.bash"
source "$HOME/bin/gitcolours.ps1.bash"

# Put readline into vi mode
set -o vi

# Don't munge ! characters in commands, they're super annoying to properly escape.
# This disables history expansion like 'sudo !!', but I don't use those anyway.
set +o histexpand

# This sets env vars and sets up keychain if needed, without locking the agent
source "$HOME/bin/setup-keychain.bash" -Q

# This is needed for gpg to work
export GPG_TTY=$(tty)

# Add ruby gem executables to path
for rubypath in /home/mike/.gem/ruby/*/bin; do
	PATH="$rubypath:$PATH"
done
# Add go binaries to PATH (see GOPATH below)
PATH="$HOME/.go/bin:$PATH"
# Add ~/bin to PATH, allowing user-specific scripts to be called anywhere
PATH="$HOME/bin:$PATH"

# source auto-complete scripts
source "/usr/share/git/completion/git-completion.bash"
source "/usr/share/bash-completion/completions/pass"
source "$HOME/bin/git-alias-completion.bash"
source <(kubectl completion bash)
source <(pmk completion --shell=bash)
source "$HOME/bin/auto-alias-completions.bash"

# Wrapper around xargs and sudo to expand aliases
_maybe_expand_alias() {
	local cmd="$(which "$1")"
	local subcmd="$2"
	local leading=()
	shift 2
	if [ "$(type -t -- "$subcmd")" = 'alias' ]; then
		leading=(${BASH_ALIASES[$subcmd]}) # note intentional no quotes
	else
		leading=("$subcmd")
	fi
	"$cmd" "${leading[@]}" "$@"
}
xargs() { _maybe_expand_alias xargs "$@"; }
sudo() { _maybe_expand_alias sudo "$@"; }

ytplay-nostream() {
	# Credit to https://github.com/exogen/dotfiles
	# Skip DASH manifest for speed purposes. This might actually disable
	# being able to specify things like 'bestaudio' as the requested format,
	# but try anyway.
	youtube-dl --default-search=ytsearch: \
	       --youtube-skip-dash-manifest \
	       --output="/tmp/%(title)s-%(id)s.%(ext)s" \
	       --restrict-filenames \
	       --format="bestaudio" \
	       --exec='mplayer -vo null -softvol -volume 50' "$*"
}

ytplay() {
	# As per ytplay-nostream but stream directly into mplayer. This disables seek.
	mplayer -vo null <(
		youtube-dl --default-search=ytsearch: \
			--youtube-skip-dash-manifest \
			--format="bestaudio" \
			--no-progress \
			-o- "$*"
	)
}

twitch_play() {
	if [ "$#" -lt 1 ]; then
		echo "USAGE: $0 CHANNEL [QUALITY {MPLAYER_ARGS}]" >&2
		return 255
	fi
	local channel="$1"
	local quality="${2:-source}"
	shift 2
	livestreamer twitch.tv/"$channel" "$quality" --player "mplayer -cache 1024 $* -"
}

pyedit() {
	local target="$1"
	shift 1
	local path="$(pypath "$target")"
	[ -n "$path" ] && "$EDITOR" "$path" "$@"
}

# shadow the real docker command to make "docker foo" run "docker-foo" if it exists, like git
docker() {
	local arg="$1"
	shift 1
	cmd=("docker-$arg")
	if which "$cmd" >/dev/null 2>&1; then
		cmd=$(which "$cmd")
	else
		cmd=("$(which docker)" "$arg")
	fi
	"${cmd[@]}" "$@"
}

screenshot() {
	local filepath="${1:-/tmp/screenshot.png}"
	shift
	# If path already exists, scrot won't overwrite but will append a number to filename
	rm "$filepath"
	echo "Select a screen region..."
	scrot "$@" -zs "$filepath" &&
		echo "Saved to $filepath"
}

ndurl() {
	echo "rtmp://rtmp.condorleague.tv/$1/live"
}

ndvlc() {
	for name in "$@"; do
		spawn vlc "$(ndurl "$name")"
	done
}

function aws-find () {
	local pattern="$1"
	shift 1
	aws ec2 describe-instances \
		--filters "Name=tag-value,Values=${pattern}" \
		--query "Reservations[*].Instances[*].[{
		         Name:Tags[?Key=='Name'].Value | [0],
		         InstanceID:InstanceId,
		         PrivateIP:NetworkInterfaces[0].PrivateIpAddresses[0].PrivateIpAddress}]" \
		--output text
}

kube-get-ips() {
	kubectl get pods -o json "$@" | jq -r '(if .kind == "List" then .items[] else . end)|"\(.metadata.name)\t\(.status.podIP)"'
}
complete -o default -F __start_kubectl kube-get-ips

# wrap a command in a check to prompt confirmation if this appears to be an ssh session
# useful for preventing accidential eg. poweroff to the wrong machine
check-ssh() {
	if [ -n "$SSH_CONNECTION" ]; then
		host=$(hostname)
		echo -en "WARNING: This appears to be an ssh connection.\nYou are connected to $host.\nPlease type this name to confirm: " >&2
		read response
		if [ "$response" != "$host" ]; then
			return 1
		fi
	fi
	"$@"
}

confirm() {
	local confirm_word="$1"
	shift
	echo -en "Please confirm by typing $confirm_word:"
	read response
	if [ "$response" != "$confirm_word" ]; then
		return 1
	fi
	"$@"
}

# list pacnew files present in /etc
list_pacnew() {
	find '/etc' \
		-type d \! -perm '-g+r,u+r,o+r' -prune \
		-or -type f -name '*.pacnew' -print
	# first line omits unreadable directories, second line searches for pacnew files
}
check_pacnew() {
	[ -z "$(list_pacnew)" ]
}
diff_pacnew() {
	for path in $(list_pacnew); do
		original="${path%.pacnew}"
		sudo patch-interactive "$original" "$path" || break
	done
}

# check if any ipsec associations exist to verify vpn connection
check_vpn() {
	sudo ipsec status|grep -Fq 'Security Associations (1 up,'
}

# exit success if bashrc has not changed since executing (matches saved hash of bashrc)
# 
# note: vulnerable to a race if edited while executing, causing a false success,
# but not a real risk.
# note: doesn't check other files, only ~/.bashrc
check_bashrc() {
	local new_digest=`sha512sum "$HOME/.bashrc" | cut -f1 -d' '`
	[ "$new_digest" == "$BASHRC_DIGEST" ]
}
BASHRC_DIGEST=`sha512sum "$HOME/.bashrc" | cut -f1 -d' '`

# Warn if our running kernel is no longer our installed kernel
# (we need to reboot). This happens when the linux package is upgraded.
check_kernel_version() {
	[ -d "/usr/lib/modules/$(uname -r)" ]
}

# Warn if we are in a git repo and have an active stash ref
check_git_stash() {
	! git show-ref --verify refs/stash >/dev/null 2>&1
}

# Warn if we are in a subshell started by "git with", since I always forget
check_git_with_nesting() {
	return "${GIT_WITH_NESTING_LEVEL:-0}"
}

# Colour aliases
alias ls='ls --color=auto'
alias grep='grep --color=auto'
alias egrep='egrep --color=auto'
alias fgrep='fgrep --color=auto'
alias tree='tree -C'

# Priveilge aliases
alias fuck='sudo $(history -p \!\!)'
alias svim='sudo vim'
alias scat='sudo cat'
alias sumv='sudo mv'
alias sucp='sudo cp'

# Other aliases
alias 'pip-upgrade'='sudo PYTHONWARNINGS=ignore pip2 install -U --no-deps'
alias commit='git commit -av'
alias status='git status -sb'
alias clock-small='watch -n1 date'
alias pso='ps -o pid,start,command'
alias rflakes='pyflakes .'
alias rflakes-watch='watch -pn.2 "pyflakes ."'
alias pyflakes-watch='watch -pn.2 pyflakes'
alias ':q'='sl'
alias vun='sl'
alias ks='sl'
alias diff='diff --color -u'
alias diffab='diff /tmp/a /tmp/b'
alias ''='clear'
alias ''='cd && clear'
alias browser='spawn $BROWSER'
alias mplayer-music='mplayer -vo null'
alias monstercat='twitch_play monstercat audio_only'
alias xclip='xclip -selection clipboard'
alias kc='kubectl'
alias kubectx='kubectl config use-context'
alias kubeset='kubectl config set-context'
alias pclip='pass show -c'
alias qr='qrencode -t ANSIUTF8 -o-'
# ^X: cd to `pwd` - this "refreshes" the fd if the dir has been destroyed/recreated (eg. in a git rebase)
alias ''='cd ~+'
# ^X^X: cd to top of git repo
alias ''='cd "$(git rev-parse --show-toplevel)"'

# PS1 alerts (see alerts.ps1.bash)
ALERTS=(check_bashrc check_pacnew check_kernel_version check_git_stash check_git_with_nesting check_vpn)

# Env vars
HISTFILESIZE=$(( 1024 * 1024 ))
HISTSIZE=$(( 1024 * 1024 ))
export EDITOR='vim'
export VISUAL='vim'
export BROWSER='firefox-developer-edition'
export PAGER='less'
export LESS='-SR'
export BANNER='banner-stripped -c# -f2'
export PYTHONSTARTUP="$HOME/.pythonrc"
export QUOTING_STYLE='literal'
export GOPATH="$HOME/.go"
export PYTHONWARNINGS=ignore # heavy-handed but i can't work out how to make pip shut up otherwise
[ -f "$HOME/.secrets" ] && source "$HOME/.secrets" # set sensitive env vars, eg. api secrets

# Postmates-specific
STAGE='stage.us-west-2.aws.k8s'
GKE_STAGE='gke_gke-stage-51680_us-west1_gke-stage'
PROD='prod.us-west-1.aws.k8s'
ADMIN='admin.us-east-2.aws.k8s'
export VAULT_ADDR='https://vault.postmates.net:8200'

pmk() {
	if [ "$1" == "login" ]; then
		"$(which pmk)" "$@" --no-switch-context
	else
		"$(which pmk)" "$@"
	fi
}

# Misc completions
complete -c which
complete -c spawn

# These aliases need to not exist, see below
for a in systemctl-user pacman user_pacman pip shutdown reboot poweroff systemctl ip wifi-menu mplayer; do
	unalias "$a" 2>/dev/null
done

# Apply completions to aliases wherever possible, see ~/bin/auto-alias-completions.bash
alias_completion

# These aliases seem to cause issues with alias_completion and so must be defined afterwards to be excluded
alias 'systemctl-user'="$(which systemctl) --user"
alias pacman='sudo pacman'
alias user_pacman="`which pacman`" # unpriviliged pacman
alias pip='sudo PYTHONWARNINGS=ignore pip2'
alias shutdown="check-ssh confirm boot sudo $(which shutdown)"
alias reboot="check-ssh confirm boot sudo $(which reboot)"
alias poweroff="check-ssh confirm boot sudo $(which poweroff)"
alias systemctl='sudo systemctl'
alias ip='sudo ip'
alias 'wifi-menu'='sudo wifi-menu'
alias mplayer="check-ssh $(which mplayer)"
alias off-screens="check-ssh $(which off-screens)"
